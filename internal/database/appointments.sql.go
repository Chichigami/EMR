// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointments.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createAppointmentForPatient = `-- name: CreateAppointmentForPatient :one
INSERT INTO appointments (
    patient_id, date_of, reasoning
) 
VALUES (
    $1, $2, $3
)
RETURNING id, created_at, updated_at, date_of, patient_id, reasoning
`

type CreateAppointmentForPatientParams struct {
	PatientID int32
	DateOf    time.Time
	Reasoning sql.NullString
}

func (q *Queries) CreateAppointmentForPatient(ctx context.Context, arg CreateAppointmentForPatientParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, createAppointmentForPatient, arg.PatientID, arg.DateOf, arg.Reasoning)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DateOf,
		&i.PatientID,
		&i.Reasoning,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments
WHERE id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAppointment, id)
	return err
}

const getAllPatientsOnDate = `-- name: GetAllPatientsOnDate :many
SELECT 
    p.first_name,
    p.middle_name,
    p.last_name,
    p.date_of_birth,
    p.sex,
    p.gender,
    p.social_security_number,
    p.pharmacy,
    p.email,
    p.location_address,
    p.zip_code,
    p.cell_phone_number,
    p.home_phone_number,
    p.marital_status,
    p.insurance,
    p.primary_care_doctor,
    p.extra_note
FROM appointments a
JOIN patients p ON a.patient_id = p.patient_id
WHERE a.date_of::DATE = $1
`

type GetAllPatientsOnDateRow struct {
	FirstName            string
	MiddleName           sql.NullString
	LastName             string
	DateOfBirth          time.Time
	Sex                  string
	Gender               string
	SocialSecurityNumber sql.NullString
	Pharmacy             string
	Email                sql.NullString
	LocationAddress      string
	ZipCode              string
	CellPhoneNumber      sql.NullString
	HomePhoneNumber      sql.NullString
	MaritalStatus        sql.NullString
	Insurance            sql.NullString
	PrimaryCareDoctor    sql.NullString
	ExtraNote            sql.NullString
}

func (q *Queries) GetAllPatientsOnDate(ctx context.Context, dateOf time.Time) ([]GetAllPatientsOnDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPatientsOnDate, dateOf)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPatientsOnDateRow
	for rows.Next() {
		var i GetAllPatientsOnDateRow
		if err := rows.Scan(
			&i.FirstName,
			&i.MiddleName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Sex,
			&i.Gender,
			&i.SocialSecurityNumber,
			&i.Pharmacy,
			&i.Email,
			&i.LocationAddress,
			&i.ZipCode,
			&i.CellPhoneNumber,
			&i.HomePhoneNumber,
			&i.MaritalStatus,
			&i.Insurance,
			&i.PrimaryCareDoctor,
			&i.ExtraNote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentBasedOnPatient = `-- name: GetAppointmentBasedOnPatient :many
SELECT id, created_at, updated_at, date_of, patient_id, reasoning
FROM appointments
WHERE patient_id = $1
`

func (q *Queries) GetAppointmentBasedOnPatient(ctx context.Context, patientID int32) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, getAppointmentBasedOnPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DateOf,
			&i.PatientID,
			&i.Reasoning,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentsBasedOnDay = `-- name: GetAppointmentsBasedOnDay :many
SELECT id, created_at, updated_at, date_of, patient_id, reasoning
FROM appointments
WHERE date_of = $1
`

func (q *Queries) GetAppointmentsBasedOnDay(ctx context.Context, dateOf time.Time) ([]Appointment, error) {
	rows, err := q.db.QueryContext(ctx, getAppointmentsBasedOnDay, dateOf)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DateOf,
			&i.PatientID,
			&i.Reasoning,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointment = `-- name: UpdateAppointment :exec
UPDATE appointments
SET date_of = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateAppointmentParams struct {
	ID     uuid.UUID
	DateOf time.Time
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) error {
	_, err := q.db.ExecContext(ctx, updateAppointment, arg.ID, arg.DateOf)
	return err
}
